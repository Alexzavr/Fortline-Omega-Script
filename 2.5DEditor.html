<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2.5D Grid Editor</title>
  <style>
    body { margin: 0; background: #111; color: white; font-family: sans-serif; user-select: none; }
    canvas { background: #222; display: block; margin: 0 auto; cursor: crosshair; }
    #controls { padding: 10px; text-align: center; }
    input, select, button, label { margin: 5px; }
    #coordDisplay { position: absolute; left: 10px; top: 10px; background: rgba(0,0,0,0.7); padding: 4px 8px; border-radius: 4px; font-size: 14px; }
  </style>
</head>
<body>
  <div id="controls">
    Layer (Y): <input type="number" id="layer" min="0" max="99" value="0">
    Model: 
    <select id="model">
      <option value="Wall$0$0">Wall</option>
      <option value="Floor$0$0">Floor</option>
      <option value="Ramp$0$0">Ramp</option>
      <option value="Window$0$0">Window</option>
      <option value="Door$0$0">Door</option>
      <option value="RampLeft$0$0">RampLeft</option>
      <option value="RampBack$0$0">RampBack</option>
    </select>
    <button onclick="rotateModel()">Rotate (R)</button>
    <label><input type="checkbox" id="showLower" /> Показати шари знизу</label>
    <button onclick="exportLua()">Export Lua</button>
    <button onclick="clearCurrentLayer()">Clear Current Layer</button>
    Width: <input type="number" id="gridWidth" value="20" min="1" max="100">
    Height: <input type="number" id="gridHeight" value="20" min="1" max="100">
    <button onclick="resizeGrid()">Resize Grid</button>
    Pos X: <input type="number" id="posX" value="10">
    Pos Y: <input type="number" id="posY" value="5">
    Pos Z: <input type="number" id="posZ" value="0">
  </div>
  <div id="coordDisplay"></div>
  <canvas id="canvas" width="800" height="800"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const cellSize = 40;
    let cols = canvas.width / cellSize;
    let rows = canvas.height / cellSize;
    let offsetX = Math.floor(cols / 2);
    let offsetZ = Math.floor(rows / 2);

    let isMouseDown = false;
    let rightClick = false;
    let grid = {}; // key = x,y,z ; value = Set of model strings

    const getLayer = () => parseInt(document.getElementById('layer').value);
    const showLowerCheckbox = document.getElementById('showLower');
    const coordDisplay = document.getElementById('coordDisplay');
    let currentRotation = 0;

    const getModel = () => {
      const modelType = document.getElementById('model').value.split('$')[0];
      return `${modelType}$${currentRotation}$0`;
    };

    function rotateModel() {
      currentRotation = (currentRotation + 90) % 360;
      drawGrid();
    }

    document.addEventListener('keydown', e => {
      if (e.key.toLowerCase() === 'r') rotateModel();
    });

    const getPosOffset = () => [
      parseInt(document.getElementById('posX').value),
      parseInt(document.getElementById('posY').value),
      parseInt(document.getElementById('posZ').value),
    ];

    canvas.addEventListener('mousedown', e => {
      isMouseDown = true;
      rightClick = e.button === 2;
      handleClick(e);
    });

    canvas.addEventListener('mouseup', () => isMouseDown = false);
    canvas.addEventListener('mouseleave', () => isMouseDown = false);
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / cellSize - offsetX);
      const z = Math.floor((e.clientY - rect.top) / cellSize - offsetZ);
      coordDisplay.innerText = `x: ${x}, y: ${getLayer()}, z: ${z}`;
      if (isMouseDown) handleClick(e);
    });

    canvas.addEventListener('contextmenu', e => e.preventDefault());

    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const delta = Math.sign(e.deltaY);
      const shift = e.shiftKey ? 10 : 1;
      const layerInput = document.getElementById('layer');
      let newVal = parseInt(layerInput.value) + delta * shift;
      newVal = Math.max(parseInt(layerInput.min), Math.min(parseInt(layerInput.max), newVal));
      layerInput.value = newVal;
      drawGrid();
    });

    function handleClick(e) {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / cellSize - offsetX);
      const z = Math.floor((e.clientY - rect.top) / cellSize - offsetZ);
      const y = getLayer();
      const key = `${x},${y},${z}`;
      if (!grid[key]) grid[key] = new Set();
      const model = getModel();

      if (rightClick) {
        grid[key].delete(model);
        if (grid[key].size === 0) delete grid[key];
      } else {
        grid[key].add(model);
      }

      drawGrid();
    }

    function drawModel(x, z, model, alpha = 1.0) {
      const x1 = Math.floor((x + offsetX) * cellSize);
      const y1 = Math.floor((z + offsetZ) * cellSize);

      ctx.globalAlpha = alpha;

      const [type, angleStr] = model.split('$');
      const angle = parseInt(angleStr);

      if (type === "Floor") {
        ctx.fillStyle = "#666";
        ctx.fillRect(x1 + 4, y1 + 4, cellSize - 8, cellSize - 8);
      } else {
        ctx.strokeStyle = "#00f";
        ctx.lineWidth = 2;
        ctx.beginPath();
        const cx = x1 + cellSize / 2;
        const cy = y1 + cellSize / 2;
        const half = cellSize / 2 - 5;
        switch (angle) {
          case 0:   ctx.moveTo(cx + half, cy - half); ctx.lineTo(cx + half, cy + half); break;
          case 90:  ctx.moveTo(cx - half, cy - half); ctx.lineTo(cx + half, cy - half); break;
          case 180: ctx.moveTo(cx - half, cy - half); ctx.lineTo(cx - half, cy + half); break;
          case 270: ctx.moveTo(cx - half, cy + half); ctx.lineTo(cx + half, cy + half); break;
          default:
            ctx.fillStyle = "#00f";
            ctx.fillRect(x1 + 8, y1 + 8, cellSize - 16, cellSize - 16);
        }
        ctx.stroke();
      }

      ctx.globalAlpha = 1.0;
    }

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let x = 0; x < cols; x++) {
        for (let z = 0; z < rows; z++) {
          ctx.strokeStyle = '#444';
          ctx.strokeRect(x * cellSize, z * cellSize, cellSize, cellSize);
        }
      }

      ctx.fillStyle = "#0f0";
      ctx.fillRect((offsetX) * cellSize - 2, (offsetZ) * cellSize - 2, 4, 4);

      const currentLayer = getLayer();

      for (const key in grid) {
        const [gx, gy, gz] = key.split(',').map(Number);
        if (!showLowerCheckbox.checked && gy !== currentLayer) continue;
        const alpha = gy === currentLayer ? 1.0 : 0.15;
        for (const model of grid[key]) {
          drawModel(gx, gz, model, alpha);
        }
      }
    }

    function exportLua() {
      const [offX, offY, offZ] = getPosOffset();
      let lua = 'local function Build(Model, x, y, z)\n';
      lua += '    local args = {\n';
      lua += '        Model,\n';
      lua += `        vector.create(x + ${offX}, y + ${offY}, z + ${offZ})\n`;
      lua += '    }\n';
      lua += '    game:GetService("ReplicatedStorage"):WaitForChild("BuildingSystem"):WaitForChild("Libraries"):WaitForChild("Grid"):WaitForChild("AddGridObject"):FireServer(unpack(args))\n';
      lua += 'end\n\n';
      for (const key in grid) {
        const [x, y, z] = key.split(',').map(Number);
        for (const model of grid[key]) {
          lua += `Build(\"${model}\", ${x}, ${y}, ${z})\n`;
        }
      }
      const blob = new Blob([lua], {type: "text/plain"});
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "export.lua";
      link.click();
    }

    function clearCurrentLayer() {
      const y = getLayer();
      for (const key in grid) {
        const [x, gy, z] = key.split(',').map(Number);
        if (gy === y) {
          delete grid[key];
        }
      }
      drawGrid();
    }

    function resizeGrid() {
      const width = parseInt(document.getElementById('gridWidth').value);
      const height = parseInt(document.getElementById('gridHeight').value);
      canvas.width = width * cellSize;
      canvas.height = height * cellSize;
      cols = width;
      rows = height;
      offsetX = Math.floor(cols / 2);
      offsetZ = Math.floor(rows / 2);
      drawGrid();
    }

    drawGrid();
  </script>
</body>
</html>
