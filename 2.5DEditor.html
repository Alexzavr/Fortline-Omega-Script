<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8" />
<title>Canvas 2.5D Grid with Angled Walls</title>
<style>
  body {
    margin: 0; background: #222; color: white; font-family: monospace;
    user-select: none;
  }
  canvas {
    display: block;
    margin: 10px auto;
    background: #111;
    cursor: crosshair;
  }
  #info {
    text-align: center;
    margin-bottom: 10px;
  }
</style>
</head>
<body>

<div id="info">Координати: <span id="coords">-</span></div>
<canvas id="canvas" width="800" height="800"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const cellSize = 40;
const cols = canvas.width / cellSize;
const rows = canvas.height / cellSize;

const offsetX = Math.floor(cols / 2);
const offsetZ = Math.floor(rows / 2);

const coordsDisplay = document.getElementById('coords');

let grid = {};

// Приклад моделей у сітці (x,y,z => set моделей)
grid["0,0,0"] = new Set(["Wall$0"]);
grid["1,0,0"] = new Set(["Wall$90"]);
grid["-1,0,0"] = new Set(["Wall$180"]);
grid["0,0,1"] = new Set(["Wall$270"]);
grid["2,0,0"] = new Set(["Floor$0"]);

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left)/cellSize - offsetX);
  const z = Math.floor((e.clientY - rect.top)/cellSize - offsetZ);
  coordsDisplay.textContent = `x: ${x}, y: 0, z: ${z}`;
});

function drawModel(x, z, model, alpha=1.0) {
  const x1 = Math.floor((x + offsetX) * cellSize);
  const y1 = Math.floor((z + offsetZ) * cellSize);

  ctx.globalAlpha = alpha;

  const parts = model.split('$');
  const type = parts[0];
  const angle = parts.length > 1 ? parseInt(parts[1]) : 0;

  if (type === "Floor") {
    ctx.fillStyle = "#666";
    ctx.fillRect(x1 + 4, y1 + 4, cellSize - 8, cellSize - 8);
  } else if (type === "Wall") {
    ctx.strokeStyle = "#00f";
    ctx.lineWidth = 2;
    ctx.beginPath();

    const cx = x1 + cellSize / 2;
    const cy = y1 + cellSize / 2;
    const half = cellSize / 2 - 5;

    switch (angle) {
      case 0:   ctx.moveTo(cx + half, cy - half); ctx.lineTo(cx + half, cy + half); break;
      case 90:  ctx.moveTo(cx - half, cy - half); ctx.lineTo(cx + half, cy - half); break;
      case 180: ctx.moveTo(cx - half, cy - half); ctx.lineTo(cx - half, cy + half); break;
      case 270: ctx.moveTo(cx - half, cy + half); ctx.lineTo(cx + half, cy + half); break;
      case 45:  ctx.moveTo(cx + half, cy - half); ctx.lineTo(cx - half, cy + half); break;
      case 135: ctx.moveTo(cx - half, cy - half); ctx.lineTo(cx + half, cy + half); break;
      case 225: ctx.moveTo(cx - half, cy + half); ctx.lineTo(cx + half, cy - half); break;
      case 315: ctx.moveTo(cx + half, cy + half); ctx.lineTo(cx - half, cy - half); break;
      default:
        ctx.fillStyle = "#00f";
        ctx.fillRect(x1 + 8, y1 + 8, cellSize - 16, cellSize - 16);
    }
    ctx.stroke();
  }

  ctx.globalAlpha = 1.0;
}

function drawGrid() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Малюємо сітку
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  for (let i = 0; i <= cols; i++) {
    ctx.beginPath();
    ctx.moveTo(i * cellSize, 0);
    ctx.lineTo(i * cellSize, canvas.height);
    ctx.stroke();
  }
  for (let j = 0; j <= rows; j++) {
    ctx.beginPath();
    ctx.moveTo(0, j * cellSize);
    ctx.lineTo(canvas.width, j * cellSize);
    ctx.stroke();
  }

  // Підсвічуємо центральну клітинку 0,0
  ctx.fillStyle = 'rgba(0,255,0,0.3)';
  ctx.fillRect(offsetX*cellSize, offsetZ*cellSize, cellSize, cellSize);

  // Малюємо всі моделі з grid
  for (const key in grid) {
    const [x, y, z] = key.split(',').map(Number);
    for (const model of grid[key]) {
      drawModel(x, z, model);
    }
  }
}

drawGrid();

</script>

</body>
</html>
